<?xml version="1.0" encoding="UTF-8"?>
<chapter
    xmlns="http://docbook.org/ns/docbook" version="5.0"
    xmlns:xl="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd
        http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd">
    
    <title>Spring Mobile Device Module</title>
    
    <section xml:id="spring-mobile-device-introduction">
    
        <title>Introduction</title>
        
        <para>Device detection is useful when requests by mobile devices need to be handled differently from requests made by desktop browsers. The Spring Mobile Device module provides support for server-side device detection. This support consists of a device resolution framework, site preference management, and site switcher.</para>
        
    </section>

    <section xml:id="spring-mobile-device-howtoget">
    
        <title>How to get</title>
        
        <para>To get the module, add the spring-mobile-device artifact to your classpath:
        
            <programlisting language="xml"><![CDATA[
<dependency>
    <groupId>org.springframework.mobile</groupId>
    <artifactId>spring-mobile-device</artifactId>
    <version>${org.springframework.mobile-version}</version>
</dependency>]]>
            </programlisting>
            
        </para>
        
        <para>Release versions are available from the following repository:
        
            <programlisting language="xml"><![CDATA[
<repository>
    <id>springsource-repo</id>
    <name>SpringSource Repository</name>
    <url>http://repo.springsource.org/release</url>
</repository>]]>
            </programlisting>
            
        </para>
        
        <para>If you are developing against a milestone version, such as 1.1.0.M1, you will need to add the following repository in order to resolve the artifact:
        
            <programlisting language="xml"><![CDATA[
<repository>
    <id>springsource-milestone</id>
    <name>SpringSource Milestone Repository</name>
    <url>http://repo.springsource.org/milestone</url>
</repository>]]>
            </programlisting>
            
        </para>
        
        <para>If you are testing the latest snapshot build version (e.g. 1.1.0.BUILD-SNAPSHOT), you will need to add the following repository:
        
            <programlisting language="xml"><![CDATA[
<repository>
    <id>springsource-snapshot</id>
    <name>SpringSource Snapshot Repository</name>
    <url>http://repo.springsource.org/snapshot</url>
</repository>]]>
            </programlisting>
            
        </para>
        
    </section>

    <section xml:id="spring-mobile-device-resolution">

        <title>Device resolution</title>
        
        <para>Device resolution is the process of introspecting an HTTP request to determine the device that originated the request. It is typically achieved by analyzing the User-Agent header and other request headers.</para>
        
        <para>At the most basic level, device resolution answers the question: "Is the client using a mobile or tablet device?". This answer enables your application to respond differently to mobile devices that have small screens, or tablet devices that have a touch interface. More sophisticated device resolvers are also capable of identifying specific device capabilities, such as screen size, manufacturer, model, or preferred markup.</para>
        
        <para>In Spring Mobile, the <interfacename>DeviceResolver</interfacename> interface defines the API for device resolution:
        
            <programlisting language="java"><![CDATA[
public interface DeviceResolver {

    Device resolveDevice(HttpServletRequest request);
    
}]]>
            </programlisting>
            
        </para>
            
        <para>The returned <interfacename>Device</interfacename> models the result of device resolution:
            
            <programlisting language="java"><![CDATA[
public interface Device {
    
    /**
     * True if this device is not a mobile or tablet device.
     */
    boolean isNormal();

    /**
     * True if this device is a mobile device such as an Apple iPhone or an Nexus One Android.
     * Could be used by a pre-handle interceptor to redirect the user to a dedicated mobile web site.
     * Could be used to apply a different page layout or stylesheet when the device is a mobile device.
     */
    boolean isMobile();
    
    /**
     * True if this device is a tablet device such as an Apple iPad or a Motorola Xoom.
     * Could be used by a pre-handle interceptor to redirect the user to a dedicated tablet web site.
     * Could be used to apply a different page layout or stylesheet when the device is a tablet device.
     */
    boolean isTablet();

}]]>
            </programlisting>
            
        </para>
            
        <para>As shown above, <methodname>Device.isMobile()</methodname> can be used to determine if the client is using a mobile device, such as a smart phone. Similarly, <methodname>Device.isTablet()</methodname> can be used to determine if the client is running on a tablet device. Depending on the <interfacename>DeviceResolver</interfacename> in use, a <interfacename>Device</interfacename> may support being downcast to access additional properties.</para>
        
        <section xml:id="spring-mobile-device-request-handling">
        
            <title>When to perform</title>
            
            <para>Web applications should perform device resolution at the beginning of request processing, before any request handler is invoked. This ensures the <interfacename>Device</interfacename> model can be made available in request scope before any processing occurs. Request handlers can then obtain the <interfacename>Device</interfacename> instance and use it to respond differently based on its state.</para>
            
            <para>By default, a <classname>LiteDeviceResolver</classname> is used for device resolution. You may plug-in another <interfacename>DeviceResolver</interfacename> implementation by injecting a constructor argument.</para>
            
            <section xml:id="spring-mobile-device-resolver-interceptor">
            
                <title>DeviceResolverHandlerInterceptor</title>
                
                <para>Spring Mobile ships with a <interfacename>HandlerInterceptor</interfacename> that, on <methodname>preHandle</methodname>, delegates to a <interfacename>DeviceResolver</interfacename>. The resolved <interfacename>Device</interfacename> is indexed under a request attribute named 'currentDevice', making it available to handlers throughout request processing.</para>
                
                <para>To enable, add the <classname>DeviceResolverHandlerInterceptor</classname> to the list of interceptors defined in your <classname>DispatcherServlet</classname> configuration:
                
                    <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
</mvc:interceptors>]]>
                    </programlisting>
                    
                </para>
                
                <para>Alternatively, you can add the <classname>DeviceResolverHandlerInterceptor</classname> using Spring's <ulink url="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java">Java-based container configuration</ulink>: 
                
                <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new DeviceResolverHandlerInterceptor());
}]]>
                    </programlisting>
                
                </para>
                
            </section>
            
            <section xml:id="spring-mobile-device-resolver-filter">
            
                <title>DeviceResolverRequestFilter</title>
                
                <para>Spring Mobile also ships with a Servlet Filter that delegates to a <interfacename>DeviceResolver</interfacename>. As with the <interfacename>HandlerInterceptor</interfacename>, the resolved <interfacename>Device</interfacename> is indexed under a request attribute named 'currentDevice', making it available to handlers throughout request processing.</para>
                
                <para>To enable, add the <classname>DeviceResolverRequestFilter</classname> to your web.xml:
                
                    <programlisting language="xml"><![CDATA[
<filter>
    <filter-name>deviceResolverRequestFilter</filter-name>
    <filter-class>org.springframework.mobile.device.DeviceResolverRequestFilter</filter-class>
</filter>]]>
                    </programlisting>
                    
                </para>
                
            </section>
            
        </section>
        
        <section xml:id="spring-mobile-device-web-argument-resolver">
        
            <title>Obtaining a reference to the current device</title>
            
            <para>When you need to lookup the current <interfacename>Device</interfacename> in your code, you can do so in several ways. If you already have a reference to a <interfacename>ServletRequest</interfacename> or Spring <interfacename>WebRequest</interfacename>, simply use <classname>DeviceUtils</classname>:
            
                <programlisting language="java"><![CDATA[
Device currentDevice = DeviceUtils.getCurrentDevice(servletRequest);]]>
                </programlisting>
                
            </para>
            
            <para>If you'd like to pass the current <interfacename>Device</interfacename> as an argument to one of your <interfacename>@Controller</interfacename> methods, configure a <classname>DeviceWebArgumentResolver</classname>:
            
                <programlisting language="xml"><![CDATA[
<mvc:annotation-driven>
    <mvc:argument-resolvers>
        <beans:bean class="org.springframework.mobile.device.DeviceWebArgumentResolver" />
    </mvc:argument-resolvers>
</mvc:annotation-driven>]]>
                </programlisting>
                
            </para>
            
            <para>You can alternatively configure a <classname>DeviceHandlerMethodArgumentResolver</classname> using Java-based configuration:
            
                <programlisting language="java"><![CDATA[
public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
    argumentResolvers.add(new DeviceHandlerMethodArgumentResolver());
}]]>
                </programlisting>
                
            </para>
            
            <para>You can then inject the <interfacename>Device</interfacename> into your <interfacename>@Controllers</interfacename> as shown below:
            
                <programlisting language="java"><![CDATA[
@Controller
public class HomeController {

    private static final Logger logger = LoggerFactory.getLogger(HomeController.class);

    @RequestMapping("/")
    public void home(Device device) {
        if (device.isMobile()) {
            logger.info("Hello mobile user!");
        } else if (device.isTablet()) {
            logger.info("Hello tablet user!");
        } else {
            logger.info("Hello desktop user!");         
        }
    }

}]]>
                </programlisting>
                
            </para>
            
        </section>
        
        <section xml:id="spring-mobile-device-resolvers">
        
            <title>Supported DeviceResolver implementations</title>
            
            <para>Spring Mobile allows for the development of different DeviceResolver implementations that offer varying levels of resolution capability. The first, and the default, is a <classname>LiteDeviceResolver</classname> that detects the presence of a mobile device but does not detect specific capabilities.</para>
            
            <section xml:id="spring-mobile-device-resolvers-lite">
            
                <title>LiteDeviceResolver</title>
                
                <para>The default <interfacename>DeviceResolver</interfacename> implementation is based on the "lite" <ulink url="http://plugins.trac.wordpress.org/browser/wordpress-mobile-pack/trunk/plugins/wpmp_switcher/lite_detection.php">detection algorithm</ulink> implemented as part of the <ulink url="http://wordpress.org/extend/plugins/wordpress-mobile-pack">Wordpress Mobile Pack</ulink>. This resolver only detects the presence of a mobile or tablet device, and does not detect specific capabilities. No special configuration is required to enable this resolver, simply configure a default <classname>DeviceResolverHandlerInterceptor</classname> and it will be enabled for you.</para>
                
                <para>It is possible that the <classname>LiteDeviceResolver</classname> incorrectly identifies a User-Agent as a mobile device. The <classname>LiteDeviceResolver</classname> provides a configuration option for setting a list of User-Agent keywords that should resolve to a "normal" device, effectively overriding the default behavior. These keywords take precedence over the mobile and tablet device detection keywords. The following example illustrates how to set the normal keywords in the configuration of the <classname>DeviceResolverHandlerInterceptor</classname> by injecting a constructor argument. In this case, User-Agents that contain "iphone" and "android" would no longer resolve to a mobile device.
                
                    <programlisting language="xml"><![CDATA[
<mvc:interceptors>
        <!-- Detects the client's Device -->
        <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor">
            <beans:constructor-arg>
                <beans:bean class="org.springframework.mobile.device.LiteDeviceResolver">
                    <beans:constructor-arg>
                        <beans:list>
                            <beans:value>iphone</beans:value>
                            <beans:value>android</beans:value>
                        </beans:list>
                    </beans:constructor-arg>
                </beans:bean>
            </beans:constructor-arg>
        </beans:bean>
</mvc:interceptors>]]>
                    </programlisting>
                    
                </para>
                
                <para>The same thing can be accomplished using Java-based configuration.
                
                    <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    List<String> keywords = new ArrayList<String>();
    keywords.add("iphone");
    keywords.add("android");
    registry.addInterceptor(new DeviceResolverHandlerInterceptor(new LiteDeviceResolver(keywords)));
}]]>
                    </programlisting>
                    
                </para>
                
                <para>Alternatively, you may subclass the <classname>LiteDeviceResolver</classname>, and either set these values in the constructor, or by calling the <methodname>getNormalUserAgentKeywords()</methodname> method.</para>
                
            </section>
            
        </section>
        
    </section>

    <section xml:id="spring-mobile-site-preference">
    
        <title>Site preference management</title>
        
        <para>Device resolution is often used to determine which "site" will be served to the user. For example, a mobile user may be served a "mobile site" that contains content optimized for display on a small screen, while a desktop user would be served the "normal site". Support for multiple sites can be achieved by introspecting <methodname>Device.isMobile()</methodname> and varying controller and view rendering logic based on its value. Likewise, support for tablets is achieved by using <methodname>Device.isTablet()</methodname>.</para>
        
        <para>However, when an application supports multiple sites, allowing the user to switch between them, if desired, is considered a good usability practice. For example, a mobile user currently viewing the mobile site may wish to access the normal site instead, perhaps because some content he or she would like to access is not available through the mobile UI.</para>
        
        <para>Building on the device resolution system is a facility for this kind of "user site preference management". This facility allows the user to indicate if he or she prefers the normal, mobile or tablet sites. The indicated <interfacename>SitePreference</interfacename> may then be used to vary control and view rendering logic.</para>
        
        <para>The <interfacename>SitePreferenceHandler</interfacename> interface defines the core service API for site preference management:
        
            <programlisting language="java"><![CDATA[
public interface SitePreferenceHandler {

    /**
     * The name of the request attribute that holds the current user's site preference value.
     */
    final String CURRENT_SITE_PREFERENCE_ATTRIBUTE = "currentSitePreference";

    /**
     * Handle the site preference aspect of the web request.
     * Implementations should first check if the user has indicated a site preference.
     * If so, the indicated site preference should be saved and remembered for future requests.
     * If no site preference has been indicated, an implementation may derive a default site preference from the {@link Device} that originated the request.
     * After handling, the user's site preference is returned and also available as a request attribute named 'currentSitePreference'.
     */
     SitePreference handleSitePreference(HttpServletRequest request, HttpServletResponse response);

}]]>
            </programlisting>
            
        </para>
            
        <para>The resolved SitePreference is an enum value:
            
            <programlisting language="java"><![CDATA[
public enum SitePreference {
    
    /**
     * The user prefers the 'normal' site.
     */
    NORMAL {
        public boolean isNormal() {
            return true;
        }
    },
    
    /**
     * The user prefers the 'mobile' site.
     */
    MOBILE {        
        public boolean isMobile() {
            return true;
        }
    },
    
    /**
     * The user prefers the 'tablet' site.
     */
    TABLET {        
        public boolean isTablet() {
            return true;
        }
    };
    
    /**
     * Tests if this is the 'normal' SitePreference.
     * Designed to support concise SitePreference boolean expressions e.g. <c:if test="${currentSitePreference.normal}"></c:i>.
     */
    public boolean isNormal() {
        return (!isMobile() && !isTablet());
    }

    /**
     * Tests if this is the 'mobile' SitePreference.
     * Designed to support concise SitePreference boolean expressions e.g. <c:if test="${currentSitePreference.mobile}"></c:i>.
     */
    public boolean isMobile() {
        return false;
    }
    
    /**
     * Tests if this is the 'tablet' SitePreference.
     * Designed to support concise SitePreference boolean expressions e.g. <c:if test="${currentSitePreference.tablet}"></c:i>;.
     */
    public boolean isTablet() {
        return false;
    }
    
}]]>
            </programlisting>
            
        </para>
        
        <para>Spring Mobile provides a single <interfacename>SitePreferenceHandler</interfacename> implementation named <classname>StandardSitePreferenceHandler</classname>, which should be suitable for most needs. It supports query-parameter-based site preference indication, pluggable <classname>SitePreference</classname> storage, and may be enabled in a Spring MVC application using a HandlerIntercepor. In addition, if no <interfacename>SitePreference</interfacename> has been explcitly indicated by the user, a default will be derived based on the user's Device (MOBILE for mobile devices, TABLET for tablet devices,  and NORMAL otherwise).</para>
        
        <section xml:id="spring-mobile-site-preference-indicating">
        
            <title>Indicating a site preference</title>
            
            <para>The user may indicate a site preference by activating a link that submits the site_preference query parameter:
            
                <programlisting language="xml"><![CDATA[
Site: <a href="${currentUrl}?site_preference=normal">Normal</a> | <a href="${currentUrl}?site_preference=mobile">Mobile</a>]]>
                </programlisting>
                
                The indicated site preference is saved for the user in a <interfacename>SitePreferenceRepository</interfacename>, and made available as a request attribute named 'currentSitePreference'.
                
            </para>
            
        </section>
        
        <section xml:id="spring-mobile-site-preference-storage">
        
            <title>Site preference storage</title>
            
            <para>Indicated site preferences are stored in a <interfacename>SitePreferenceRepository</interfacename> so they are remembered in future requests made by the user. <classname>CookieSitePreferenceRepository</classname> is the default implementation and stores the user's' preference in a client-side cookie.
            
                <programlisting language="java"><![CDATA[
public interface SitePreferenceRepository {

    /**
     * Load the user's site preference.
     * Returns null if the user has not specified a preference.
     */
    SitePreference loadSitePreference(HttpServletRequest request);
    
    /**
     * Save the user's site preference.
     */
    void saveSitePreference(SitePreference preference, HttpServletRequest request, HttpServletResponse response);

}]]>
                </programlisting>
            
            </para>
            
        </section>
        
        <section xml:id="spring-mobile-site-preference-interceptor">
        
            <title>Enabling site preference management</title>
            
            <para>To enable <interfacename>SitePreference</interfacename> management before requests are processed, add the <classname>SitePreferenceHandlerInterceptor</classname> to your <classname>DispatcherServlet</classname> configuration:</para>
            
            <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, manage the user's site preference (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.site.SitePreferenceHandlerInterceptor" />
</mvc:interceptors>]]>
            </programlisting>
            
            <para>Java-based configuration is also available:</para>
            
            <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new DeviceResolverHandlerInterceptor());
    registry.addInterceptor(new SitePreferenceHandlerInterceptor());
}]]>
            </programlisting>
            
            <para>By default, the interceptor will delegate to a <classname>StandardSitePreferenceHandler</classname> configured with a <classname>CookieSitePreferenceRepository</classname>. You may plug-in another <interfacename>SitePreferenceHandler</interfacename> by injecting a constructor argument. After the interceptor is invoked, the <classname>SitePreference</classname> will be available as a request attribute named 'currentSitePreference'.</para>
            
        </section>
        
        <section xml:id="spring-mobile-site-preference-argument-resolver">
        
            <title>Obtaining a reference to the current site preference</title>
            
            <para>When you need to lookup the current <classname>SitePreference</classname> in your code, you can do so in several ways. If you already have a reference to a <interfacename>ServletRequest</interfacename> or Spring <interfacename>WebRequest</interfacename>, simply use <classname>SitePreferenceUtils</classname>:</para>
            
            <programlisting language="java"><![CDATA[
SitePreference sitePreference = SitePreferenceUtils.getCurrentSitePreference(servletRequest);]]>
            </programlisting>
            
            <para>If you'd like to pass the current <classname>SitePreference</classname> as an argument to one of your <interfacename>@Controller</interfacename> methods, configure a <classname>SitePreferenceWebArgumentResolver</classname>:
            
                <programlisting language="xml"><![CDATA[
<mvc:annotation-driven>
    <mvc:argument-resolvers>
        <beans:bean class="org.springframework.mobile.device.DeviceWebArgumentResolver" />
        <beans:bean class="org.springframework.mobile.device.site.SitePreferenceWebArgumentResolver" />        
    </mvc:argument-resolvers>
</mvc:annotation-driven>]]>
                </programlisting>
                
            </para>
            
            <para>Java-based configuration is also available:
            
                <programlisting language="java"><![CDATA[
public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) { 
    argumentResolvers.add(new DeviceHandlerMethodArgumentResolver());
    argumentResolvers.add(new SitePreferenceHandlerMethodArgumentResolver());
}]]>
                </programlisting>
                
            </para>
            
            <para>You can then inject the indicated <classname>SitePreference</classname> into your <interfacename>@Controller</interfacename> as shown below:
            
                <programlisting language="java"><![CDATA[
@Controller
public class HomeController {

    @RequestMapping("/")
    public String home(SitePreference sitePreference, Model model) {
        if (sitePreference == SitePreference.NORMAL) {
            logger.info("Site preference is normal");
            return "home";
        } else if (sitePreference == SitePreference.MOBILE) {
            logger.info("Site preference is mobile");
            return "home-mobile";
        } else if (sitePreference == SitePreference.TABLET) {
            logger.info("Site preference is tablet");
            return "home-tablet";
        } else {
            logger.info("no site preference");
            return "home";
        }
    }

}]]>
                </programlisting>
                
            </para>
             
        </section>
        
    </section>
    
    <section xml:id="spring-mobile-device-site-switcher-interceptor">
    
        <title>Site switching</title>
        
        <para>Some applications may wish to host their "mobile site" at a different domain from their "normal site". For example, Google will switch you to <literal>m.google.com</literal> if you access <literal>google.com</literal> from your mobile phone.</para>
        
        <para>In Spring Mobile, you may use the <classname>SiteSwitcherHandlerInterceptor</classname> to redirect mobile users to a dedicated mobile site. Users may also indicate a site preference; for example, a mobile user may still wish to use the 'normal' site. Convenient static factory methods are provided that implement standard site switching conventions.</para>
        
        <section xml:id="spring-mobile-site-switcher-interceptor-mdot">
        
            <title>mDot SiteSwitcher</title>
            
            <para>Use the <methodname>mDot</methodname> factory method to construct a SiteSwitcher that redirects mobile users to m.${serverName}; for example, <literal>m.myapp.com</literal>:
            
                <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, redirects mobile users to "m.myapp.com" (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="mDot">
        <beans:constructor-arg index="0" type="java.lang.String" value="myapp.com"/>
    </beans:bean>
</mvc:interceptors>]]>
                </programlisting>
                
                By default, tablet devices see the 'normal' site. A second constructor argument is available for specifying that tablet devices are redirected to the 'mobile' site:
                
                <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, redirects mobile users to "m.myapp.com" (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="mDot">
        <beans:constructor-arg index="0" type="java.lang.String" value="myapp.com"/>
        <beans:constructor-arg index="1" type="java.lang.Boolean" value="true"/>
    </beans:bean>
</mvc:interceptors>]]>
                </programlisting>
                
                Java-based configuration is also available:
                
                <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new DeviceResolverHandlerInterceptor());
    registry.addInterceptor(SiteSwitcherHandlerInterceptor.mDot("myapp.com", true));
}]]>
                </programlisting>
                
            </para>
            
        </section>
        
        <section xml:id="spring-mobile-site-switcher-interceptor-dotmobi">
        
            <title>dotMobi SiteSwitcher</title>
            
            <para>
                Use the <methodname>dotMobi</methodname> factory method to construct a SiteSwitcher that redirects mobile users to ${serverName - lastDomain}.mobi; for example, <literal>myapp.mobi</literal>:
                <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, redirects mobile users to "myapp.mobi" (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="dotMobi">
        <beans:constructor-arg index="0" type="java.lang.String" value="myapp.com"/>
    </beans:bean>
</mvc:interceptors>]]>
                </programlisting>
                
                As described earlier with the <methodname>mDot</methodname> factory method, tablet devices see the 'normal' site. A second constructor argument is available for specifying that tablet devices are redirected to the 'mobile' site:
                
                <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, redirects mobile users to "myapp.mobi" (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="dotMobi">
        <beans:constructor-arg index="0" type="java.lang.String" value="myapp.com"/>
        <beans:constructor-arg index="1" type="java.lang.Boolean" value="true"/>
    </beans:bean>
</mvc:interceptors>]]>
                </programlisting>
                
                Java-based configuration is also available:
                
                <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new DeviceResolverHandlerInterceptor());
    registry.addInterceptor(SiteSwitcherHandlerInterceptor.dotMobi("myapp.com", true));
}]]>
                </programlisting>
                
            </para>
            
        </section>

        <section xml:id="spring-mobile-site-switcher-interceptor-urlpath">
            
            <title>urlPath SiteSwitcher</title>
            
            <para>Use the <methodname>urlPath</methodname> factory method to construct a SiteSwitcher that redirects mobile users to a different path within the application. Unlike <methodname>mDot</methodname> and <methodname>dotMobi</methodname>, this SiteSwitcher does not require setting up a different DNS entry for a mobile site.</para>

            <section>
            
                <title>Mobile Path</title>
            
                <para>Use the <methodname>urlPath</methodname> factory method to construct a SiteSwitcher that redirects mobile users to ${serverName}/${mobilePath}; for example, <literal>myapp.com/m/</literal>:
                
                    <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, redirects mobile users to "myapp.com/m" (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="urlPath">
        <beans:constructor-arg index="0" type="java.lang.String" value="/m" />
    </beans:bean>
</mvc:interceptors>]]>
                    </programlisting>
            
            Java-based configuration is also available:
            
                    <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new DeviceResolverHandlerInterceptor());
    registry.addInterceptor(SiteSwitcherHandlerInterceptor.urlPath("/m"));
}]]>
                    </programlisting>
            
                </para>
                
            </section>
            
            <section>
            
                <title>Mobile Path and Root Path</title>
            
                <para>You can also specify the root path of the application in the <methodname>urlPath</methodname> factory method. The following sample constructs a SiteSwitcher that redirects mobile users to ${serverName}/${rootPath}/${mobilePath}; for example, <literal>myapp.com/showcase/m/</literal>:
                
                    <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, redirects mobile users to "myapp.com/showcase/m" (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="urlPath">
        <beans:constructor-arg index="0" type="java.lang.String" value="/m" />
        <beans:constructor-arg index="1" type="java.lang.String" value="/showcase" />
    </beans:bean>
</mvc:interceptors>]]>
                    </programlisting>
                
            Java-based configuration is also available:
            
                    <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new DeviceResolverHandlerInterceptor());
    registry.addInterceptor(SiteSwitcherHandlerInterceptor.urlPath("/m", "/showcase"));
}]]>
                    </programlisting>
            
                </para>
                
            </section>
            
            <section>
            
                <title>Mobile Path, Tablet Path, and Root Path</title>
            
                <para>Lastly, the <methodname>urlPath</methodname> factory method supports configuring a path for a tablet site. The following sample constructs a SiteSwitcher that redirects mobile users to ${serverName}/${rootPath}/${mobilePath} for mobile sites, and ${serverName}/${rootPath}/${tabletPath} for tablet sites.</para>
            
                <para>In the following configuration example, the mobile site would be located at <literal>myapp.com/showcase/m/</literal>, while the tablet site would be similarly located at <literal>myapp.com/showcase/t/</literal>:
                
                    <programlisting language="xml"><![CDATA[
<mvc:interceptors>
    <!-- On pre-handle, resolve the device that originated the web request -->
    <beans:bean class="org.springframework.mobile.device.DeviceResolverHandlerInterceptor" />
    <!-- On pre-handle, redirects mobile users to "myapp/showcase/m" (declare after DeviceResolverHandlerInterceptor) -->
    <beans:bean class="org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor" factory-method="urlPath">
        <beans:constructor-arg index="0" type="java.lang.String" value="/m" />
        <beans:constructor-arg index="1" type="java.lang.String" value="/t" />
        <beans:constructor-arg index="2" type="java.lang.String" value="/showcase" />
    </beans:bean>
</mvc:interceptors>]]>
                    </programlisting>
                
                Java-based configuration is also available:
            
                    <programlisting language="java"><![CDATA[
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new DeviceResolverHandlerInterceptor());
    registry.addInterceptor(SiteSwitcherHandlerInterceptor.urlPath("/m", "/t", "/showcase"));
}]]>
                    </programlisting>
            
                </para>
                
            </section>
            
            <section>
            
                <title>Additional Configuration</title>
                
                <para>Please note that in order for the <methodname>urlPath</methodname> SiteSwitcher to work properly, you will need to add a corresponding url pattern to your web.xml for the mobile and tablet site paths.</para>
            
                <programlisting language="xml"><![CDATA[
<servlet-mapping>
    <servlet-name>appServlet</servlet-name>
    <url-pattern>/</url-pattern>
    <url-pattern>/m/*</url-pattern>
    <url-pattern>/t/*</url-pattern>
</servlet-mapping>]]>
                </programlisting>
            
            </section>
        
        </section>
            
        <para>The <methodname>mDot</methodname>, <methodname>dotMobi</methodname> and <methodname>urlPath</methodname> factory methods configure cookie-based <interfacename>SitePreference</interfacename> storage. The cookie value will be shared across the mobile and normal site domains. Internally, the interceptor delegates to a <interfacename>SitePreferenceHandler</interfacename>, so there is no need to register a <classname>SitePreferenceHandlerInterceptor</classname> when using the switcher.</para>
            
        <para>See the JavaDoc of <classname>SiteSwitcherHandlerInterceptor</classname> for additional options when you need more control. See the spring-mobile <ulink url="https://github.com/SpringSource/spring-mobile-samples">samples</ulink> repository for runnable SiteSwitcher examples.</para>
        
    </section>

    <section xml:id="spring-mobile-device-view-resolution">

        <title>Device aware view management</title>

        <para>Using device detection, it is possible to add conditional logic within your controllers to return
        specific views based on device type. But this process can be laborious if you are dealing with a large
        number of views. Fortunately, Spring Mobile offers an alternative method for managing views for different
        device types.</para>

        <section xml:id="spring-mobile-device-view-delegating-resolver">

            <title>Device aware view resolving</title>

            <para>Spring Mobile includes <classname>AbstractDeviceDelegatingViewResolver</classname>, an abstract
            <classname>ViewResolver</classname> wrapper that delegates to  another view resolver implementation,
            allowing for resolution of device specific view names without the need for a dedicated mapping to be
            defined for each view. A lightweight implementation is provided, which supports adjusting view names
            based on whether the calling device is normal, mobile, or tablet based.</para>

            <para>Within your application, you can then create alternate views for normal, mobile or tablet devices,
            and given the proper configuration, Spring Mobile will adjust the view name to resolve to the correct one.
            This happens internally, without the need to add conditional logic through your controllers. The following
            table illustrates the behavior of the <classname>LiteDeviceDelegatingViewResolver</classname> when
            receiving a request for the "home" view and adjusting it to use a prefix. This allows you to store
            "mobile" views in a subdirectory, for example.</para>

            <table>
                <title>Prefixes</title>
                <tgroup cols="4">
                <thead>
                    <row>
                        <entry>Resolved Device</entry>
                        <entry>Method</entry>
                        <entry>Prefix</entry>
                        <entry>Adjusted View</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>Normal</entry>
                        <entry><methodname>setNormalPrefix()</methodname></entry>
                        <entry>"normal/"</entry>
                        <entry>"normal/home"</entry>
                    </row>
                    <row>
                        <entry>Mobile</entry>
                        <entry><methodname>setMobilePrefix()</methodname></entry>
                        <entry>"mobile/"</entry>
                        <entry>"mobile/home"</entry>
                    </row>
                    <row>
                        <entry>Tablet</entry>
                        <entry><methodname>setTabletPrefix()</methodname></entry>
                        <entry>"tablet/"</entry>
                        <entry>"tablet/home"</entry>
                    </row>
                </tbody>
                </tgroup>
            </table>

            <para>Alternatively, the <classname>LiteDeviceDelegatingViewResolver</classname> also supports adjusting
            views with suffixes. The following table shows the results of receiving a request for the "home" view.
            For example, this allows you to store all your views in the same folder, and distinguish between them by
            using different suffixes.</para>

            <table>
                <title>Suffixes</title>
                <tgroup cols="4">
                <thead>
                    <row>
                        <entry>Resolved Device</entry>
                        <entry>Method</entry>
                        <entry>Suffix</entry>
                        <entry>Adjusted View</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>Normal</entry>
                        <entry><methodname>setNormalSuffix()</methodname></entry>
                        <entry>".nor"</entry>
                        <entry>"home.nor"</entry>
                    </row>
                    <row>
                        <entry>Mobile</entry>
                        <entry><methodname>setMobileSuffix()</methodname></entry>
                        <entry>".mob"</entry>
                        <entry>"home.mob"</entry>
                    </row>
                    <row>
                        <entry>Tablet</entry>
                        <entry><methodname>setTabletSuffix()</methodname></entry>
                        <entry>".tab"</entry>
                        <entry>"home.tab"</entry>
                    </row>
                </tbody>
                </tgroup>
            </table>

        </section>

        <section>

            <title>Enabling device aware views</title>

            <para>The following example illustrates how to configure a site that delegates to an
            <classname>InternalResourceViewResolver</classname>. It is configurated to adjust the view name by adding
            a <literal>mobile/</literal> or <literal>tablet/</literal> prefix if the requesting device is determined
            to be mobile or tablet respectively.</para>

            <para>XML configuration:

                <programlisting language="xml"><![CDATA[
<beans:bean class="org.springframework.mobile.device.view.LiteDeviceDelegatingViewResolver">
    <beans:constructor-arg>
        <beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
            <beans:property name="prefix" value="/WEB-INF/views/" />
            <beans:property name="suffix" value=".jsp" />
        </beans:bean>
    </beans:constructor-arg>
    <beans:property name="mobilePrefix" value="mobile/" />
    <beans:property name="tabletPrefix" value="tablet/" />
</beans:bean>]]>
                </programlisting>

            </para>

            <para>Java-based configuration:

                <programlisting language="java"><![CDATA[
@Bean
public LiteDeviceDelegatingViewResolver liteDeviceAwareViewResolver() {
    InternalResourceViewResolver delegate = new InternalResourceViewResolver();
    delegate.setPrefix("/WEB-INF/views/");
    delegate.setSuffix(".jsp");
    LiteDeviceDelegatingViewResolver resolver = new LiteDeviceDelegatingViewResolver(delegate);
    resolver.setMobilePrefix("mobile/");
    resolver.setTabletPrefix("tablet/");
    return resolver;
}]]>
                </programlisting>

            </para>

        </section>

        <section>

            <title>Fallback resolution</title>

            <para>Because using a <interfacename>ViewResolver</interfacename> will apply the view name strategy to
            your entire site, there may be times when some of your views do not have separate implementations for
            different device types or you do not need different versions. In this case, you can enable fallback
            support. Enabling fallback support means if an adjusted view name cannot be resolved, the
            <interfacename>ViewResolver</interfacename> will attempt to resolve the original view request. In the
            following examples, the previous configurations have been adjusted to enable fallback support.</para>

            <para>XML configuration:

                <programlisting language="xml"><![CDATA[
<beans:bean class="org.springframework.mobile.device.view.LiteDeviceDelegatingViewResolver">
    <beans:constructor-arg>
        <beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
            <beans:property name="prefix" value="/WEB-INF/views/" />
            <beans:property name="suffix" value=".jsp" />
        </beans:bean>
    </beans:constructor-arg>
    <beans:property name="enableFallback" value="true" />
    <beans:property name="mobilePrefix" value="mobile/" />
    <beans:property name="tabletPrefix" value="tablet/" />
</beans:bean>]]>
                </programlisting>

            </para>

            <para>Java-based configuration:

                <programlisting language="java"><![CDATA[
@Bean
public LiteDeviceDelegatingViewResolver liteDeviceAwareViewResolver() {
    InternalResourceViewResolver delegate = new InternalResourceViewResolver();
    delegate.setPrefix("/WEB-INF/views/");
    delegate.setSuffix(".jsp");
    LiteDeviceDelegatingViewResolver resolver = new LiteDeviceDelegatingViewResolver(delegate);
    resolver.setEnableFallback(true);
    resolver.setMobilePrefix("mobile/");
    resolver.setTabletPrefix("tablet/");
    return resolver;
}]]>
                </programlisting>

            </para>

        </section>

    </section>

</chapter>